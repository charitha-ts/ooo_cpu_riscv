module issue_queue #(
    parameter IQ_SIZE = 8,
    parameter PHYS_REG_IDX_W = 4,    // e.g. enough bits for physical reg index
    parameter ROB_IDX_W = 4,
    parameter OPCODE_W = 6
) (
    input  logic clk,
    input  logic reset,
    input  logic flush,                     // flush signal (branch mispredict etc.)

    // Dispatch inputs
    input  logic dispatch_en,
    input  logic [OPCODE_W-1:0] dispatch_opcode,
    input  logic [PHYS_REG_IDX_W-1:0] dispatch_rs1_tag,
    input  logic dispatch_rs1_ready,
    input  logic [PHYS_REG_IDX_W-1:0] dispatch_rs2_tag,
    input  logic dispatch_rs2_ready,
    input  logic [PHYS_REG_IDX_W-1:0] dispatch_dest_tag,
    input  logic [ROB_IDX_W-1:0] dispatch_rob_idx,

    // CDB broadcast for wakeup - 2 CDBs (for 2 FUs)
    input  logic cdb0_valid,
    input  logic [PHYS_REG_IDX_W-1:0] cdb0_tag,
    input  logic cdb1_valid,
    input  logic [PHYS_REG_IDX_W-1:0] cdb1_tag,

    // Functional Unit ready signals
    input  logic fu0_ready,
    input  logic fu1_ready,

    // Issue outputs for FU0
    output logic issue0_valid,
    output logic [OPCODE_W-1:0] issue0_opcode,
    output logic [PHYS_REG_IDX_W-1:0] issue0_dest_tag,
    output logic [ROB_IDX_W-1:0] issue0_rob_idx,
    output logic [PHYS_REG_IDX_W-1:0] issue0_rs1_tag,
    output logic issue0_rs1_ready,
    output logic [PHYS_REG_IDX_W-1:0] issue0_rs2_tag,
    output logic issue0_rs2_ready,
    output logic issue0_rs1_wakeup,
    output logic issue0_rs2_wakeup,

    // Issue outputs for FU1
    output logic issue1_valid,
    output logic [OPCODE_W-1:0] issue1_opcode,
    output logic [PHYS_REG_IDX_W-1:0] issue1_dest_tag,
    output logic [ROB_IDX_W-1:0] issue1_rob_idx,
    output logic [PHYS_REG_IDX_W-1:0] issue1_rs1_tag,
    output logic issue1_rs1_ready,
    output logic [PHYS_REG_IDX_W-1:0] issue1_rs2_tag,
    output logic issue1_rs2_ready,
    output logic issue1_rs1_wakeup,
    output logic issue1_rs2_wakeup,

    output logic iq_full
);

    typedef struct packed {
        logic valid;
        logic [OPCODE_W-1:0] opcode;
        logic [PHYS_REG_IDX_W-1:0] rs1_tag;
        logic rs1_ready;
        logic [PHYS_REG_IDX_W-1:0] rs2_tag;
        logic rs2_ready;
        logic [PHYS_REG_IDX_W-1:0] dest_tag;
        logic [ROB_IDX_W-1:0] rob_idx;
    } iq_entry_t;

    iq_entry_t iq [IQ_SIZE];

    // Free entries mask and full signal
    logic [IQ_SIZE-1:0] free_entries;
    assign free_entries = ~{iq[0].valid, iq[1].valid, iq[2].valid, iq[3].valid,
                            iq[4].valid, iq[5].valid, iq[6].valid, iq[7].valid};
    assign iq_full = (free_entries == 8'b0);

    // Find first free slot for dispatch
    logic [2:0] dispatch_slot;
    integer i;
    always_comb begin
        dispatch_slot = 0;
        for (i = 0; i < IQ_SIZE; i++) begin
            if (!iq[i].valid) begin
                dispatch_slot = i;
                break;
            end
        end
    end

    // Wakeup logic for 2 CDBs
    logic [IQ_SIZE-1:0] rs1_wakeup_mask_cdb0, rs2_wakeup_mask_cdb0;
    logic [IQ_SIZE-1:0] rs1_wakeup_mask_cdb1, rs2_wakeup_mask_cdb1;

    always_comb begin
        for (int j = 0; j < IQ_SIZE; j++) begin
            rs1_wakeup_mask_cdb0[j] = (iq[j].valid && !iq[j].rs1_ready && cdb0_valid && (iq[j].rs1_tag == cdb0_tag));
            rs2_wakeup_mask_cdb0[j] = (iq[j].valid && !iq[j].rs2_ready && cdb0_valid && (iq[j].rs2_tag == cdb0_tag));
            rs1_wakeup_mask_cdb1[j] = (iq[j].valid && !iq[j].rs1_ready && cdb1_valid && (iq[j].rs1_tag == cdb1_tag));
            rs2_wakeup_mask_cdb1[j] = (iq[j].valid && !iq[j].rs2_ready && cdb1_valid && (iq[j].rs2_tag == cdb1_tag));
        end
    end

    // Combine wakeup masks from both CDBs
    logic [IQ_SIZE-1:0] rs1_wakeup_mask, rs2_wakeup_mask;
    assign rs1_wakeup_mask = rs1_wakeup_mask_cdb0 | rs1_wakeup_mask_cdb1;
    assign rs2_wakeup_mask = rs2_wakeup_mask_cdb0 | rs2_wakeup_mask_cdb1;

    // Ready mask for instructions with both operands ready
    logic [IQ_SIZE-1:0] ready_mask;
    always_comb begin
        for (int k = 0; k < IQ_SIZE; k++) begin
            ready_mask[k] = (iq[k].valid && iq[k].rs1_ready && iq[k].rs2_ready);
        end
    end

    // Find the oldest ready instruction for FU0
    logic issue0_found;
    logic [ROB_IDX_W-1:0] issue0_min_rob_idx;
    logic [2:0] issue0_slot;

    always_comb begin
        issue0_found = 0;
        issue0_min_rob_idx = {ROB_IDX_W{1'b1}}; // max value
        issue0_slot = 0;

        for (int m = 0; m < IQ_SIZE; m++) begin
            if (ready_mask[m]) begin
                if (!issue0_found || (iq[m].rob_idx < issue0_min_rob_idx)) begin
                    issue0_min_rob_idx = iq[m].rob_idx;
                    issue0_slot = m;
                    issue0_found = 1;
                end
            end
        end
    end

    // Find the oldest ready instruction for FU1, excluding FU0's chosen instruction
    logic issue1_found;
    logic [ROB_IDX_W-1:0] issue1_min_rob_idx;
    logic [2:0] issue1_slot;

    always_comb begin
        issue1_found = 0;
        issue1_min_rob_idx = {ROB_IDX_W{1'b1}};
        issue1_slot = 0;

        for (int n = 0; n < IQ_SIZE; n++) begin
            if (ready_mask[n] && n != issue0_slot) begin
                if (!issue1_found || (iq[n].rob_idx < issue1_min_rob_idx)) begin
                    issue1_min_rob_idx = iq[n].rob_idx;
                    issue1_slot = n;
                    issue1_found = 1;
                end
            end
        end
    end

    // Gate issue with FU readiness
    assign issue0_valid = issue0_found && fu0_ready;
    assign issue1_valid = issue1_found && fu1_ready;

    // Outputs for FU0
    assign issue0_opcode    = issue0_valid ? iq[issue0_slot].opcode    : '0;
    assign issue0_dest_tag  = issue0_valid ? iq[issue0_slot].dest_tag  : '0;
    assign issue0_rob_idx   = issue0_valid ? iq[issue0_slot].rob_idx   : '0;
    assign issue0_rs1_tag   = issue0_valid ? iq[issue0_slot].rs1_tag   : '0;
    assign issue0_rs1_ready = issue0_valid ? iq[issue0_slot].rs1_ready : 1'b0;
    assign issue0_rs2_tag   = issue0_valid ? iq[issue0_slot].rs2_tag   : '0;
    assign issue0_rs2_ready = issue0_valid ? iq[issue0_slot].rs2_ready : 1'b0;
    assign issue0_rs1_wakeup= issue0_valid ? rs1_wakeup_mask[issue0_slot] : 1'b0;
    assign issue0_rs2_wakeup= issue0_valid ? rs2_wakeup_mask[issue0_slot] : 1'b0;

    // Outputs for FU1
    assign issue1_opcode    = issue1_valid ? iq[issue1_slot].opcode    : '0;
    assign issue1_dest_tag  = issue1_valid ? iq[issue1_slot].dest_tag  : '0;
    assign issue1_rob_idx   = issue1_valid ? iq[issue1_slot].rob_idx   : '0;
    assign issue1_rs1_tag   = issue1_valid ? iq[issue1_slot].rs1_tag   : '0;
    assign issue1_rs1_ready = issue1_valid ? iq[issue1_slot].rs1_ready : 1'b0;
    assign issue1_rs2_tag   = issue1_valid ? iq[issue1_slot].rs2_tag   : '0;
    assign issue1_rs2_ready = issue1_valid ? iq[issue1_slot].rs2_ready : 1'b0;
    assign issue1_rs1_wakeup= issue1_valid ? rs1_wakeup_mask[issue1_slot] : 1'b0;
    assign issue1_rs2_wakeup= issue1_valid ? rs2_wakeup_mask[issue1_slot] : 1'b0;

    // Main sequential logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            for (int idx = 0; idx < IQ_SIZE; idx++) begin
                iq[idx].valid      <= 1'b0;
                iq[idx].opcode     <= '0;
                iq[idx].rs1_tag    <= '0;
                iq[idx].rs1_ready  <= 1'b0;
                iq[idx].rs2_tag    <= '0;
                iq[idx].rs2_ready  <= 1'b0;
                iq[idx].dest_tag   <= '0;
                iq[idx].rob_idx    <= '0;
            end
        end else if (flush) begin
            // On flush, clear all IQ entries
            for (int idx = 0; idx < IQ_SIZE; idx++) begin
                iq[idx].valid <= 1'b0;
            end
        end else begin
            // Wakeup operands if CDB matches
            for (int idx = 0; idx < IQ_SIZE; idx++) begin
                if (iq[idx].valid) begin
                    if (rs1_wakeup_mask[idx]) iq[idx].rs1_ready <= 1'b1;
                    if (rs2_wakeup_mask[idx]) iq[idx].rs2_ready <= 1'b1;
                end
            end

            // Issue instructions: clear only if FU accepted instruction
            if (issue0_valid) iq[issue0_slot].valid <= 1'b0;
            if (issue1_valid) iq[issue1_slot].valid <= 1'b0;

            // Dispatch new instruction if valid and IQ not full
            if (dispatch_en && !iq_full) begin
                iq[dispatch_slot].valid     <= 1'b1;
                iq[dispatch_slot].opcode    <= dispatch_opcode;
                iq[dispatch_slot].rs1_tag   <= dispatch_rs1_tag;
                iq[dispatch_slot].rs1_ready <= dispatch_rs1_ready;
                iq[dispatch_slot].rs2_tag   <= dispatch_rs2_tag;
                iq[dispatch_slot].rs2_ready <= dispatch_rs2_ready;
                iq[dispatch_slot].dest_tag  <= dispatch_dest_tag;
                iq[dispatch_slot].rob_idx   <= dispatch_rob_idx;
            end
        end
    end

endmodule
